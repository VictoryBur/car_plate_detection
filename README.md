# Распознавание китайских автомобильных номеров (CCPD)

Проект автоматического распознавания китайских автомобильных номеров с использованием глубокого обучения. Реализованы две ключевые задачи: детекция номеров на изображении (YOLO) и распознавание текста (CRNN).

[![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)](https://www.python.org/downloads/)
[![PyTorch](https://img.shields.io/badge/PyTorch-2.0+-red.svg)](https://pytorch.org/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

Проект решает задачу автоматического распознавания китайских автомобильных номеров в два этапа:

1. **Object Detection (Детекция объектов)** - определение местоположения номерного знака на изображении с использованием YOLOv8
2. **Sequence Recognition (Распознавание последовательности)** - OCR распознавание символов номера с помощью CRNN (Convolutional Recurrent Neural Network)

### Формат китайского номерного знака

Китайский автомобильный номер состоит из **8 символов**:
- **1 символ** - провинция (китайский иероглиф)
- **2 символа** - латинские буквы
- **5 символов** - цифры и буквы

Пример: `皖A12345` или `京B67890`

## Датасет

Используется **CCPD (Chinese City Parking Dataset)**, 2020 год - один из крупнейших датасетов для распознавания китайских номеров.

Датасет загружается через Kaggle API:
```bash
kaggle datasets download -d lyhue1991/ccpd-green
```

## Архитектура решения

### 1. Object Detection - YOLOv8

**Модель**: YOLOv8n (nano версия для быстрой детекции)

**Характеристики**:
- Входное изображение: 640×640 пикселей
- Один класс: `license_plate`
- Формат меток: YOLO (нормализованные координаты центра, ширины и высоты)

**Процесс обучения**:
```python
- Эпохи: 50
- Batch size: 16
- Оптимизатор: AdamW
- Image augmentation: HSV, Flip, Mosaic
```

### 2. Sequence Recognition - CRNN

**Архитектура модели**:

```
Input (128×32×3) 
    ↓
CNN Feature Extractor (ResNet-based)
    ↓
Bidirectional LSTM (256 units × 2 layers)
    ↓
Fully Connected Layer
    ↓
CTC Loss
    ↓
Output (8 символов)
```

**Детали архитектуры**:
- **CNN backbone**: 
  - 4 сверточных блока с Batch Normalization
  - MaxPooling для уменьшения размерности
  - Dropout (0.3) для регуляризации
  
- **RNN слой**:
  - BiLSTM с 256 скрытыми единицами
  - 2 рекуррентных слоя
  - Dropout между слоями (0.5)

- **Функция потерь**: CTC Loss (Connectionist Temporal Classification)

##  Результаты

### Финальные метрики на тестовой выборке

#### Общая точность
| Метрика | Значение |
|---------|----------|
| **Точность полного совпадения** | **84.95%** |
| **Среднее edit distance** | **0.28** |

#### Точность по позициям символов

| Позиция | Символ | Точность |
|---------|--------|----------|
| 1 | Провинция | 98.27% |
| 2 | Буква 1 | 99.65% |
| 3 | Буква 2 | 99.65% |
| 4 | Цифра 1 | 97.58% |
| 5 | Цифра 2 | 95.16% |
| 6 | Цифра 3 | 94.12% |
| 7 | Цифра 4 | 93.43% |
| 8 | Цифра 5 | 92.04% |



## Установка

### Требования

- Python 3.8+
- CUDA 11.0+ (для GPU ускорения, опционально)
- 8GB RAM (минимум)

```
torch>=2.0.0
torchvision>=0.15.0
ultralytics>=8.0.0
opencv-python>=4.8.0
numpy>=1.24.0
pandas>=2.0.0
matplotlib>=3.7.0
pillow>=10.0.0
tqdm>=4.65.0
editdistance>=0.6.2
kaggle>=1.5.0
```

##  Примеры

### Визуализация детекции

```python
import cv2
from ultralytics import YOLO

model = YOLO('best_yolo.pt')
image = cv2.imread('test_image.jpg')

results = model(image)
annotated = results[0].plot()

cv2.imwrite('result.jpg', annotated)
```

### Примеры предсказаний

| Изображение | Ground Truth | Предсказание | Корректность |
|------------|--------------|--------------|-----------|
| ![img1](examples/1.jpg) | 皖A12345 | 皖A12345 | ✅ |
| ![img2](examples/2.jpg) | 京B67890 | 京B67890 | ✅ |
| ![img3](examples/3.jpg) | 沪C98765 | 沪C98765 | ✅ |
| ![img4](examples/4.jpg) | 粤D45678 | 粤D45678 | ✅ |

### Сложные случаи

| Сценарий | Описание | Точность |
|---------|----------|----------|
| Низкое освещение | Ночные условия | 78% |
| Сильный угол | Наклон >30° | 82% |
| Дождь/грязь | Загрязненный номер | 75% |
| Малый размер | Номер <50px | 70% |

